# 02-함수

## 함수 리터럴
| 리터럴방식 | 일반적인 방식 |
|---|---|
| let hello = function(name) { <br> alert(name + "님 환영합니다."); <br> } <br> hello("홍길동"); | function hello(name){ alert(name + "님 환영합니다.");} hello("홍길동"); |

## 함수 선언
+ function 키워드를 작성하고, 함수 이름과 (매개변수 목록)을 작성한 후 { 코드블럭 }을 작성한다. 

````
<script>
    function 함수이름(매개변수 목록) {
        함수 실행부
    }
</script>
````

> ### function 키워드
> + function 키워드를 작성하면 함수 정의할 수 있다.

> ### 함수 이름 
> + 함수 이름은 function과 ()사이에 정의하고 이를 통해서 함수를 식별할 수 있다. 
>+ 메모리상에서 함수가 저장된 위치를 찾는 식별자 역할을 한다. 함수 이름을 정의하지 않은 익명함수도 존재한다. 

### 매개변수 목록
+ 함수 이름 옆에 () 소괄호 내부에 들어간다. 매개변수가 없는 함수도 존재한다.
+ 선언 시 매개변수 목록을 정의하면 함수를 호출할 때 인자값을 전달할 수 있다.

### 함수 실행부
+ 함수가 호출되면 실행되는 몸통부 코드블럭을 작성해준다.


## 익명함수
+ 함수이름을 주지 않고 리터럴 방식으로 만들어진 이름없는 함수를 익명함수 라고 부른다.
+ 함수 리터럴 이란 ? 자바스크립트에서는 함수도 데이터이므로 변수에 함수를 대입하고, 다른 함수의 인수로 전달하고, 반환값으로 함수를 건네주는 것이 가능하다.
+ 단 한번만 사용되는 함수의 경우(재사용 안함), 불필요한 시간동안 메모리를 차지하지 않도록 따로 함수의 이름을 갖지 않는다. 
+ 변수 할당했으니 함수 이름처럼 사용해서 익명 함수를 실행한다. 
+ 함수가 이름을 갖는 것과 변수에 저장되는 것은 다르다.
+ 함수에서 return은 함수의 실행을 강제종료한다. 그러므로 reture문 아래의 로직은 작동하지 않는다.

## return

## 매개변수

````
<script>
    // 익명함수는 연결된 이름이 없는 함수
    // 익명 함수 선언 및 변수에 대입
    let sayHello = function () {
        document.write("안녕하세요 <br>")
    }

    sayHello(); // 변수 sayHello에 할당했으니 함수 이름처럼 사용해서 익명 함수를 실행한다.

    // 리턴값이 있는 익명함수
    function func() {
        document.write("1. 함수가 실행되었습니다. <br>");
        return;

        document.write("2. 함수가 실행되었습니다. <br>"); // 실행안됨
    }

    func();

    // 매개변수 + 리턴문
    // 함수 선언 후 변수 add에 할당
    let add = function (a, b) {
        return a + b;
    }

    // 익명 함수 실행 후 결과값을 변수 sum에 저장.
    let sum = add(100, 200)
    document.write(sum , "<br>")
</script>
````

## 자바스크립트 함수 생성 2가지 방법
+ 함수 선언식(Function Declarations)
+ 함수 표현식(Function Expressions).


## 함수 선언식(Function Declarations)
+ 함수 선언식은 'function' 키워드로 시작하고 함수 이름을 명시한다.

````
<script>
    // greet 함수는 선언 전에 호출되었음에도 불구하고 정상적으로 작동한다.
    // 이는 함수 선언식이 호이스팅되기 때문.
    console.log(greet()); // "Hello, World!"

    function greet() {
        return "Hello, World!";
    }
</script>
````

## 함수 표현식(Function Expressions)
+ 함수를 생성하고 변수에 값을 할당하는 것처럼 함수를 변수에 할당한다.

````
 <script>
    var result; // var로 선언된 (함수 표현식) 변수는 호이스팅되어 undefined로 초기화
    console.log(result)

    // 변수는 undefined이고
    // undefined는 함수가 아니기 때문에 
    // 이 함수를 선언하기 전에 호출하려고 하면 TypeError가 발생
    result = minus(100, 50);
    console.log(result)

    // 함수를 함수표현식으로 변수에 할당하면 변수 호이스팅 규칙을 따른다.
    let minus = function (a, b) {
        return a - b;
    }
</script>
````

## 함수 선언식과 함수 표현식의 차이점

|   |  정의  |  함수이름 | 호이스팅 | 함수 호출 |
|---|---|---|---|---|
| 함수 선언식 | 'function' 키워드로 시작하고 함수 이름을 명시 | 이름을 가질 수 있으며, 이 이름은 함수 내부에서만 접근 가능. | 함수 선언식은 호이스팅이 된다. 함수가 선언되기 전에도 호출할 수 있다. 호이스팅되어 함수 전체가 스코프의 최상단으로 끌어올려진다. | 사용하려면 해당 함수 이름을 호출하면 된다.  |
| 함수 표현식 | 표현식을 사용하여 정의 될 수 있으며, 함수 표현식은 변수로 저장될수 있다. | 함수 표현식으로 정의를 하게 될 때는 함수의 이름을 생략할 수 있는데 이러한 함수를 익명 함수라고 한다. 함수 표현식을 사용할 때에는 함수의 이름을 생략하는 것이 일반적이다. | 변수 호이스팅 규칙을 따르므로 호이스팅되지 않으며 선언되기 전에는 호출할 수 없다. (함수를 선언하기 전에 호출하려고 하면, TypeError 발생.) | 함수 표현식이 변수에 저장되면, 변수는 함수처럼 사용 가능해진다. 변수에 저장된 함수는 함수명이 필요 없으며, 변수 이름을 통하여 호출된다. |


### 스코프


> + 자바스크립트에서 스코프(Scope)란? 변수와 함수가 접근 가능한 범위를 의미한다. 
> + 이는 코드의 특정 영역에서 어떤 변수들을 사용할 수 있는지를 정의한다.
> + 스코프는 크게 [글로벌 스코프, 함수 스코프, 블록 레벨 스코프, 체인 스코프]로 나눌 수 있다.

> + 글로벌 스코프(Global Scope) : 글로벌 스코프에 선언된 변수는 어디서든 접근 가능. (전역 변수)
> + 함수 스코프(Function Scope) : 함수 내에서 선언된 변수는 해당 함수 내에서만 접근 가능. 외부에서는 접근할 수 없다.
> + 블록 레벨 스코프(Block Level Scope) : let과 const를 사용하여 선언된 변수는 블록 레벨 스코프를 가진다. 해당 변수가 선언된 블록(중괄호 {} 안)에서만 접근 가능.







화살표함수
https://velog.io/@gud_wns/%EC%9D%B5%EB%AA%85%ED%95%A8%EC%88%98%EC%A6%89%EC%8B%9C%EC%8B%A4%ED%96%89%ED%95%A8%EC%88%98%ED%99%94%EC%82%B4%ED%91%9C%ED%95%A8%EC%88%98

