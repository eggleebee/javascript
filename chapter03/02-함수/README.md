# 02-함수
+ 큰 프로그램을 잘게 쪼개어 자주쓰는 실행코드를 블록단위로 묶어놓은 코드 뭉치의 단위를 말한다.
+ 기능단위로 재사용하기 위해서 사용한다. (코드를 한 번 정의하고, 여러 번 사용)
+ 다른 인자를 사용하여 동일한 코드를 여러 번 사용할 수 있으며, 다른 결과를 도출할 수 있다.
+ 함수 선언은 function키워드 사용하거나 arrow function(화살표 함수=>)를 사용한다.
+ 정의되어있는 함수는 호출해야 기능이 실행된다.

## 함수 구성 요소
````
<script>
    // 함수 선언
    function add(x, y) {
        const result = x + y;
        return result;
    }

    // 함수 실행
    add(2, 3); // 5
</script>
````
> + add라는 이름을 갖는 함수를 정의. 
> + 괄호 안의 x와 y를 매개변수(parameter) : 함수 내부로 입력을 받는 변수 
> + return 뒤에 오는 값을 반환값(return value)이라고 한다.
> + 함수 이름 뒤에 괄호를 붙여서 이 함수를 실행 이를 함수의 호출(function call)이라고 한다.
> + 여기서 괄호 안에 넘겨준 2, 3을 인수(argument)라고 부른다.

## 자바스크립트 함수 생성 2가지 방법
+ 함수 선언식(Function Declarations) 
+ 함수 표현식(Function Expressions)

## 함수 선언식과 함수 표현식의 차이점

|   |  정의  |  함수이름 | 호이스팅 | 함수 호출 |
|---|---|---|---|---|
| 함수 선언식 | 'function' 키워드로 시작하고 함수 이름을 명시 | 이름을 가질 수 있으며, 이 이름은 함수 내부에서만 접근 가능. | 함수 선언식은 호이스팅이 된다. 함수가 선언되기 전에도 호출할 수 있다. 호이스팅되어 함수 전체가 스코프의 최상단으로 끌어올려진다. | 사용하려면 해당 함수 이름을 호출하면 된다.  |
| 함수 표현식 | 표현식을 사용하여 정의 될 수 있으며, 함수 표현식은 변수로 저장될수 있다. | 함수 표현식으로 정의를 하게 될 때는 함수의 이름을 생략할 수 있는데 이러한 함수를 익명 함수라고 한다. 함수 표현식을 사용할 때에는 함수의 이름을 생략하는 것이 일반적이다. | 변수 호이스팅 규칙을 따르므로 호이스팅되지 않으며 선언되기 전에는 호출할 수 없다. (함수를 선언하기 전에 호출하려고 하면, TypeError 발생.) | 함수 표현식이 변수에 저장되면, 변수는 함수처럼 사용 가능해진다. 변수에 저장된 함수는 함수명이 필요 없으며, 변수 이름을 통하여 호출된다. |

## 함수 선언식(Function Declarations)
+ function 키워드를 작성하면 함수를 정의할 수 있다. 함수 선언식은 'function' 키워드로 시작하고 함수 이름을 명시한다.
+ function 키워드를 작성하고, 함수 이름과 (매개변수 목록)을 작성한 후 { 코드블럭 }을 작성한다. 
+ 함수 선언문은 표현식이 아닌 문이다. 표현식이 아닌 문은 변수에 할당할 수 없으므로 함수 선언문도 변수에 할당불가능하다.

````
<script>
    function 함수이름(매개변수 목록) {
        함수 실행부 // 함수가 호출되면 실행되는 몸통부 코드블럭을 작성해준다.
    }
</script>
````

````
<script>
    // 함수 선언
    function add (x, y) {
        const result = x + y;
        console.log(result);
        return result;
    }
</script>
````

## 함수 이름 
+ 함수의 이름은 가능한 짧고 정확하게 함수의 기능을 설명해야 한다.
+ 함수 이름은 function과 ()사이에 정의하고 이를 통해서 함수를 식별할 수 있다. 
+ 함수 이름은 변수 이름과 동일한 규칙으로 문자, 숫자, 밑줄, 달러 기호가 포함될 수 있다.
+ 메모리상에서 함수가 저장된 위치를 찾는 식별자 역할을 한다. 함수 이름을 정의하지 않은 익명함수도 존재한다. 

````
<script>
    showMessage(..)		// 무언가를 보여준다.
    getAge(..)			 // 무언가를 보여준다.		
    calcSum(..)			// 무언가를 계산한다.
    createForm(..)		 // 무언가를 만든다.
    checkPermission(..)	// 무언가를 확인하고 불리언 등을 반환한다.
</script>
````

## 함수 호출
+ 함수는 선언할 때 선언 후 함수가 바로 실행되지 않는다. 
+ 함수를 사용하기 위해서는 함수를의 식별자를 이용해 호출해주어야 한다.
+ 이때 매개변수에 전달할 값을 인자 목록에 작성해줄 수 있다. 순차적으로 매개된다. 
+ 반복 사용하는 코드를 함수로 만들어 필요할 때마다 호출할 수 있다. 
+ 반복되는 코드블럭을 식별자 호출만으로 편하게 재사용이 가능하다.

````
<script>
    function 함수이름(매개변수 목록) {
        함수 실행부
    }

    함수이름(인자 목록)
</script>
````

````
<script>
    // 함수 선언
    function add (x, y) {
        let result = x + y;
        console.log(result);
        return result;
    }

    // 선언해 놓은 함수는 아래와 같이 소괄호를 이용하여 호출할 수 있다.
    // 함수를 호출한다. = 함수 내부의 코드가 실행된다.
    // 함수를 호출하기 전까지는 함수 내부의 코드 구문들은 실행되지 않는다.
    add(3, 5);
</script>
````

## 매개변수 목록
+ 함수 이름 옆에 () 소괄호 내부에 들어간다. 매개변수가 없는 함수도 존재한다.
+ 선언 시 매개변수 목록을 정의하면 함수를 호출할 때 인자값을 전달할 수 있다.

## 매개변수와 인수
+ 매개변수는 함수 선언에서 지정한 변수로, 함수의 기능을 수행하기 위해 필요한 값들을 받아들인다. 
+ 인수는 함수를 호출할 때 전달되는 값으로, 매개변수와 대응됩니다. 
+ 매개변수와 인수는 개수와 순서가 동일해야한다.


## 반환값(return)
+ 함수는 필요에 따라 결과값을 반환할 수 있다. 
+ 함수 내에서 return 키워드를 사용하여 반환하고자 하는 값 또는 표현식을 지정한다. 
+ 반환된 값은 함수를 호출한 곳으로 전달되며, 이를 이용하여 다른 작업을 수행할 수 있다.
+ return 키워드 바로 다음에 오는 값이 함수 호출의 결과값으로 반환되며, 반환되는 즉시 함수 실행이 끝난다.

````
<script>
    function func() {
        document.write("1. 함수가 실행되었습니다. <br>");
        return; 

        document.write("2. 함수가 실행되었습니다."); // 실행안됨
    }

    func();
</script>
````

````
<script>
    function add(x, y) {
        return x + y;
        console.log('이 부분은 실행되지 않습니다.');
    }
    add(1, 2); // 3
</script>
````

````
<script>
    function doSomething () {
        console.log('함수실행!');
        var a = 3;
        var b = 2;

        // if 구문 내부가 실행되면서 return 명령문이 실행됐기 때문에 return 명령문은 해당 함수를 종료시키게 된다. 
        // 현재 return 명령문이 속해있는 함수는 doSomething이기 때문에 doSomething함수의 모든 코드 실행이 종료됨으로 
        // 세번째 콘솔 메시지는 나타나지 않는다.
        if (a > b) {
            console.log('a가 b보다 크다!');
            return;
        }

        return 3;

        console.log('세번째 콘솔 메시지!'); //실행되지 않음
    }

    doSomething(); // 결과 : 함수실행!, a가 b보다 크다!
</script>
````

## 실행 순서

````
<script>
    // 1 - 함수 정의
    function add(x, y) {
        return x + y; // 3 - 함수 실행
    }
    // 2 - 함수 호출
    const result = add(2, 3);

    // 4 - 나머지 코드 실행
    console.log(result);
</script>
````

## 리터럴(literal)
+ 리터럴은 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해 값을 생성하는 표기방식을 말한다.
+ 즉, 리터럴은 값을 생성하기 위한 표기법이다.

````
<script>
    let age = 10;
    let name ="홍길동";
    let bool = true;
    let arr = ["포도","딸기"];
</script>
````

## 함수 리터럴(function literal)
````
<script
    // 변수에 함수리터럴 할당
    const add = function add(x,y){
        return x+y;
    }
    console.log(add(2,5));
</script>
````

## 익명함수
+ 함수이름을 주지 않고 리터럴 방식으로 만들어진 이름없는 함수를 익명함수 라고 부른다.
+ 함수 리터럴 이란 ? 자바스크립트에서는 함수도 데이터이므로 변수에 함수를 대입하고, 다른 함수의 인수로 전달하고, 반환값으로 함수를 건네주는 것이 가능하다.
+ 단 한번만 사용되는 함수의 경우(재사용 안함), 불필요한 시간동안 메모리를 차지하지 않도록 따로 함수의 이름을 갖지 않는다. 
+ 변수 할당했으니 함수 이름처럼 사용해서 익명 함수를 실행한다. 
+ 함수가 이름을 갖는 것과 변수에 저장되는 것은 다르다.
+ 함수에서 return은 함수의 실행을 강제종료한다. 그러므로 reture문 아래의 로직은 작동하지 않는다.

````
<script>
    // 익명함수는 연결된 이름이 없는 함수
    // 익명 함수 선언 및 변수에 대입
    let sayHello = function () {
        document.write("안녕하세요 <br>")
    }

    sayHello(); // 변수 sayHello에 할당했으니 함수 이름처럼 사용해서 익명 함수를 실행한다.
</script>
````

````
<script>
    // 매개변수 + 리턴문
    // 함수 선언 후 변수 add에 할당
    let add = function (a, b) {
        return a + b;
    }

    // 익명 함수 실행 후 결과값을 변수 sum에 저장.
    let sum = add(100, 200)
    document.write(sum , "<br>")
</script>
````

## 함수 표현식(Function Expressions)
+ 변수를 선언하고 함수를 대입하는 방식을 함수 표현식이라고 한다.
+ 함수를 생성하고 변수에 값을 할당하는 것처럼 함수를 변수에 할당한다.

````
 <script>
    const 변수명 = function(매개변수 목록) {
        코드 실행부
    }

    변수명(인수 목록)
</script>
````

````
 <script>
    var result; // var로 선언된 (함수 표현식) 변수는 호이스팅되어 undefined로 초기화
    console.log(result)

    // 변수는 undefined이고
    // undefined는 함수가 아니기 때문에 
    // 이 함수를 선언하기 전에 호출하려고 하면 TypeError가 발생
    result = minus(100, 50);
    console.log(result)

    // 함수를 함수표현식으로 변수에 할당하면 변수 호이스팅 규칙을 따른다.
    let minus = function (a, b) {
        return a - b;
    }
</script>
````

## 함수 생성 시점과 함수 호이스팅
+ 함수 선언문은  런타임(runtime) 이전에 자바스크립트 엔진에 의해 먼저 실행되어 함수 객체가 먼저 생성이 된다. 
+ 코드가 실행될 시 이미 생성된 함수의 객체를 참조할 수 있으며 심지어 호출까지 가능하다. 
+ 함수 선언문이 코드의 최상단으로 끌어 올려진 것처럼 동작하는 자바스크립트의 고유 특징을 함수 호이스팅(function hoisting)이라고 한다.
+ 함수 호이스팅은 함수를 호출하기 이전에 반드시 함수를 정의해야한다는 당연한 규칙을 무시한다. 이같은 문제 때문에 함수 선언문 대신 함수 표현식을 사용할것이 권장된다.


````
 <script>
    // 함수 선언문으로 정의한 함수는 함수 선언 전에 호출할 수 있음
    console.log(add) 

    // 함수 선언식
    function add(x, y) {
        return x + y;
    }
 </script>
````

````
<script>
    // greet 함수는 선언 전에 호출되었음에도 불구하고 정상적으로 작동한다.
    // 이는 함수 선언식이 호이스팅되기 때문.
    console.log(greet()); // "Hello, World!"

    function greet() {
        return "Hello, World!";
    }
</script>
````

````
 <script>
    // 함수표현식 이전에 함수를 참조하면 undefined로 평가된다.
    // 따라서 이때 함수를 호출하면 undefined를 호출하는것과 마찬가지이므로 타입 에러(TypeError)가 발생한다.
    // 함수 표현식으로 정의한 함수는 ReferenceError가 출력
    // 함수 표현식으로 정의한 함수는 반드시 함수 표현식 이후에 참조 또는 호출해야 한다.
    console.log(plus) 

    // 함수 표현식
    const plus = function(x, y) {
        return x + y;
    }
 </script>
````

## 스코프
+ 자바스크립트에서 스코프(Scope)란? 변수와 함수가 접근 가능한 범위를 의미한다. 
+ 이는 코드의 특정 영역에서 어떤 변수들을 사용할 수 있는지를 정의한다.


### 스코프의 구분
> + 글로벌 스코프(Global Scope) : 글로벌 스코프에 선언된 변수는 어디서든 접근 가능. (전역 변수)
> + 함수 스코프(Function Scope) : 함수 내에서 선언된 변수는 해당 함수 내에서만 접근 가능. 외부에서는 접근할 수 없다.
> + 블록 레벨 스코프(Block Level Scope) : let과 const를 사용하여 선언된 변수는 블록 레벨 스코프를 가진다. 해당 변수가 선언된 블록(중괄호 {} 안)에서만 접근 가능.

````
 <script>
    function add(x, y) { // 매개변수 `x`와 `y`가 정의됨
        return x + y;
    }

    add(2, 3);

    // 이렇게, 매개변수와 같이 함수 안에서 정의된 변수는 함수 바깥에서는 접근할 수 없기 때문에 함수 안에서만 사용할 수 있다. 
    // 스코프(scope) : 변수는 코드의 일정 범위 안에서만 유효
    console.log(x); // 에러!
 </script>
````

