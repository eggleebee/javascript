# 04-변수의 호이스팅

## hoisting(호이스팅)이란?
+ 호이스팅은 코드가 실행하기 전 **변수선언/함수선언이 해당 스코프의 최상단으로 끌어 올려진 것 같은 현상**을 말한다.
+ 자바스크립트 엔진은 코드를 실행하기 전 실행 가능한 코드를 형상화하고 구분하는 과정(*실행 컨텍스트를 위한 과정)을 거친다.
+ 자바스크립트 엔진은 코드를 실행하기 전 실행 컨텍스트를 위한과정에서 모든 선언(var, let, const, function, class)을 스코프에 등록한다.
+ 코드 실행 전 이미 변수선언/함수선언이 저장되어 있기 때문에 선언문보다 참조/호출이 먼저 나와도 오류 없이 동작한다. (정확히는 var 키워드로 선언한 변수와 함수 선언문일 경우 오류 없이 동작한다. 이는 선언이 파일의 맨 위로 끌어올려진 것 처럼 보이게 한다.)
+ **실행 컨텍스트**는 실행 가능한 **코드가 실행되기 위해 필요한 환경을 의미**하고 실행되기전 이러한 실행 컨텍스트 과정(코드를 구분하는 과정)을 거친다.

## 변수는 어떻게 생성되며, 호이스팅은 어떻게 이뤄질까?
+ 변수는 3단계에 걸쳐 생성된다.

> ### 1단계: 선언 단계(Declaration phase)
> + 변수를 실행 컨텍스트의 변수 객체에 등록한다.
> + 이 변수 객체는 스코프가 참조하는 대상이 된다.
> ### 2단계: 초기화 단계(Initialization phase)
> + 변수 객체에 등록된 변수를 위한 공간을 메모리에 확보한다.
> + 이 단계에서 변수는 undefined로 초기화 된다.
> ### 3단계: 할당 단계(Assignment phase)
> + undefined로 초기화된 변수에 실제 값을 할당한다.

## var로 선언한 변수 호이스팅
+ var 키워드로 선언한 변수는 선언 단계와 초기화 단계가 한번에 이뤄진다. 
+ 즉, 스코프에 변수를 등록(선언 단계)하고 메모리에 변수를 위한 공간을 확보한 후, undefined로 초기화한다. 
+ 따라서 변수 선언문 이전에 변수에 접근하여도 스코프에 변수가 존재하기 때문에 에러가 발생하지 않는다
+ 다만 undefined를 반환한다. 이후 변수 할당문에 도달하면 비로소 값이 할당된다.

````
<script>
    // 호이스팅 때문에 선언이 끌어올려져서 오류 안남.
    console.log(text); // (선언 + 초기화 된 상태)
    text = '안녕!'; // (선언 + 초기화 + 할당 된 상태)
    var text;
    console.log(text);
</script>
````

## let과 const로 선언한 변수 호이스팅
+ let 키워드로 선언된 변수는 선언 단계와 초기화 단계가 분리되어 진행된다. 
+ 즉, 스코프에 변수를 등록(선언 단계)하지만 초기화 단계는 변수 선언문에 도달했을 때(코드 실행 후) 이뤄진다. 
+ 초기화 이전에 변수에 접근하려고 하면 참조 에러가 발생한다. 이는 아직 변수가 초기화되지 않았기 때문이다. 
+ 즉, 변수를 위한 메모리 공간이 아직 확보되지 않았기 때문이다. 
+ 따라서 스코프의 시작 지점부터 초기화 시작 지점까지는 변수를 참조할 수 없다. 
+ 스코프의 시작 지점부터 초기화 시작 지점까지의 구간을 ‘일시적 사각지대(Temporal Dead Zone; TDZ)’라고 부른다.

````
<script>
    // 호이스팅 때문에 선언이 끌어올려졌지만 초기화 안된 상태에서 참조해서 오류 남.
    console.log(str); 
    // (선언 된 상태, 초기화(메모리 공간 확보와 undefined로 초기화) 안되서 참조 불가능 → 에러남 )
    // Uncaught ReferenceError: Cannot access 'str' before initialization
    let str; // 여기서 초기화 단계가 실행됨
</script>
````

## TDZ(Temporal Dead Zone)의 정의
+ var는 변수의 선언단계와 초기화단계가 동시에 실행되어 TDZ가 존재하지 않기 때문에 호이스팅이 일어난다.
+ TDZ 는 스코프의 시작 지점부터 초기화 시작 지점까지의 사각지대 구간을 뜻한다.(변수가 선언되고 초기화되기 사이의 사각지대)
+ let과 const는 var와는 다르게 선언단계와 초기화 단계가 따로 분리되어 실행된다.
+ 그래서 선언 단계와 초기화 단계 사이에서는 실행 컨텍스트에는 변수를 등록했지만 메모리가 할당되지 않은 상태라 ReferenceError 가 나오는 것이다.
+ 다시 말 해 let과 const는 호이스팅 되어 변수를 메모리에 올려놨지만 TDZ라는 지역에 있어 선언한 코드 줄을 지나야 접근 가능한 상태라고 보면 된다.

````
<script>
    console.log(num); // Uncaught ReferenceError: Cannot access 'num' before initialization
    let num; // num을 초기화 하지 않을 경우 접근 안됨(일시적 사각지대로 들어감)
</script>
````

       





   


